{"version":3,"file":"partykals.module.js","sources":["../partykals/utils.js","../partykals/particle.js","../partykals/material/shaders/vertex.js","../partykals/material/material.js","../partykals/material/shaders/fragment.js","../partykals/particles_system.js","../partykals/emitter.js","../partykals/randomizers/randomizer.js","../partykals/randomizers/sphere_randomizer.js","../partykals/randomizers/box_randomizer.js","../partykals/randomizers/colors_randomizer.js","../partykals/randomizers/minmax_randomizer.js"],"sourcesContent":["/**\n * Implement a single particle in the particles system.\n * Author: Ronen Ness.\n * Since: 2019.\n*/\nimport * as THREE from 'three'\n\nconst Utils = {\n\n  /**\n     * Returns a random number between min (inclusive) and max (exclusive)\n     */\n  getRandomBetween: function (min, max) {\n    return Math.random() * (max - min) + min\n  },\n\n  /**\n     * Get random between baseVal and baseVal + extraRandom.\n     * If 'extraRandom' is not defined, will just return baseVal.\n     * If baseVal is not defined, will return white.\n     */\n  getRandomWithSpread: function (baseVal, extraRandom) {\n    if (!extraRandom) { return baseVal }\n    return this.getRandomBetween(baseVal, baseVal + extraRandom)\n  },\n\n  /**\n     * Get random between two colors.\n     * If 'colMax' is not defined, will just return colMin or white color if not defined.\n     */\n  getRandomColorBetween: function (colMin, colMax) {\n    if (!colMax) { return colMin ? colMin.clone() : new THREE.Color() }\n    return new THREE.Color(\n      this.getRandomBetween(colMin.r, colMax.r),\n      this.getRandomBetween(colMin.g, colMax.g),\n      this.getRandomBetween(colMin.b, colMax.b)\n    )\n  },\n\n  /**\n     * Get random between two vectors.\n     * If 'vecMax' is not defined, will just return vecMin or zero point if not defined.\n     */\n  getRandomVectorBetween: function (vecMin, vecMax) {\n    if (!vecMax) { return vecMin ? vecMin.clone() : new THREE.Vector3() }\n    return new THREE.Vector3(\n      this.getRandomBetween(vecMin.x, vecMax.x),\n      this.getRandomBetween(vecMin.y, vecMax.y),\n      this.getRandomBetween(vecMin.z, vecMax.z)\n    )\n  },\n\n  /**\n     * Lerp between two colors, returning a new color without changing any of them.\n     */\n  lerpColors: function (colA, colB, alpha) {\n    return colA.clone().lerp(colB, alpha)\n  },\n\n  /**\n     * Lerp between two numbers.\n     */\n  lerp: function (x, y, alpha) {\n    return (x * (1 - alpha)) + (y * alpha)\n  },\n\n  /**\n     * Get const numeric value or generate random value from randomizer.\n     */\n  randomizerOrValue: function (val) {\n    return (val.generate ? val.generate() : val) || 0\n  }\n}\n\nexport { Utils }\n","/**\n * Implement a single particle in the particles system.\n * Author: Ronen Ness.\n * Since: 2019.\n*/\nimport * as THREE from 'three'\nimport { Utils } from './utils'\n\n/**\n * A single particle metadata in the particles system.\n * We attach this to the particle's vertices when in system's geometry.\n */\nclass Particle {\n  /**\n     * Create the particle.\n     * @param {ParticlesSystem} system The particles system this particle belongs to.\n     */\n  constructor (system) {\n    this.system = system\n    this.reset()\n  }\n\n  /**\n     * Reset the particle.\n     */\n  reset () {\n    var options = this.system.options.particles\n\n    // reset particle age and if alive\n    this.age = 0\n    this.finished = false\n\n    // store gravity force\n    this.gravity = options.gravity\n\n    // particle's velocity and velocity bonus\n    this.velocity = getConstOrRandomVector(options.velocity)\n    if (options.velocityBonus) { this.velocity.add(options.velocityBonus) }\n\n    // particle's acceleration.\n    this.acceleration = getConstOrRandomVector(options.acceleration, true)\n\n    // starting offset\n    this.position = getConstOrRandomVector(options.offset)\n\n    // set particle's ttl\n    this.ttl = Utils.getRandomWithSpread(options.ttl || 1, options.ttlExtra) || 1\n\n    // set per-particle alpha\n    this.alpha = this.startAlpha = this.endAlpha = null\n    this.startAlphaChangeAt = (options.startAlphaChangeAt || 0) / this.ttl\n    if (options.fade) {\n      // const alpha throughout particle's life?\n      if (options.alpha !== undefined) {\n        this.alpha = Utils.randomizerOrValue(options.alpha)\n      }\n      // shifting alpha?\n      else {\n        this.startAlpha = Utils.randomizerOrValue(options.startAlpha)\n        this.endAlpha = Utils.randomizerOrValue(options.endAlpha)\n      }\n    }\n\n    // set per-particle coloring\n    this.colorize = Boolean(options.colorize)\n    this.color = this.startColor = this.endColor = null\n    this.startColorChangeAt = (options.startColorChangeAt || 0) / this.ttl\n    if (this.colorize) {\n      // const color throughout particle's life?\n      if (options.color) {\n        this.color = getConstOrRandomColor(options.color)\n      }\n      // shifting color?\n      else {\n        this.startColor = getConstOrRandomColor(options.startColor)\n        this.endColor = getConstOrRandomColor(options.endColor)\n      }\n    }\n\n    // set per-particle size\n    this.size = this.startSize = this.endSize = null\n    this.startSizeChangeAt = (options.startSizeChangeAt || 0) / this.ttl\n    if (options.scaling) {\n      // const size throughout particle's life?\n      if (options.size !== undefined) {\n        this.size = Utils.randomizerOrValue(options.size)\n      }\n      // shifting size?\n      else {\n        this.startSize = Utils.randomizerOrValue(options.startSize)\n        this.endSize = Utils.randomizerOrValue(options.endSize)\n      }\n    }\n\n    // set per-particle rotation\n    this.rotation = this.rotationSpeed = null\n    if (options.rotating) {\n      this.rotation = Utils.randomizerOrValue(options.rotation || 0)\n      this.rotationSpeed = Utils.randomizerOrValue(options.rotationSpeed || 0)\n    }\n\n    // used to keep constant world position\n    this.startWorldPosition = null\n\n    // store on-update callback, if defined\n    this.onUpdate = options.onUpdate\n\n    // call custom spawn method\n    if (options.onSpawn) {\n      options.onSpawn(this)\n    }\n  }\n\n  /**\n     * Update the particle (call this every frame).\n     * @param {*} index Particle index in system.\n     * @param {*} deltaTime Update delta time.\n     */\n  update (index, deltaTime) {\n    // if finished, skip\n    if (this.finished) {\n      return\n    }\n\n    // is it first update call?\n    var firstUpdate = this.age === 0\n\n    // do first-update stuff\n    if (firstUpdate) {\n      // if its first update and use world position, store current world position\n      if (this.system.options.particles.worldPosition) {\n        this.startWorldPosition = this.system.getWorldPosition()\n      }\n\n      // set constant alpha\n      if (this.alpha !== null || this.startAlpha !== null) {\n        this.system.setAlpha(index, this.alpha || this.startAlpha)\n      }\n\n      // set constant color\n      if (this.color !== null || this.startColor !== null) {\n        this.system.setColor(index, this.color || this.startColor)\n      }\n\n      // set constant size\n      if (this.size !== null || this.startSize !== null) {\n        this.system.setSize(index, this.size || this.startSize)\n      }\n\n      // set start rotation\n      if (this.rotation !== null) {\n        this.system.setRotation(index, this.rotation)\n      }\n    }\n    // do normal updates\n    else {\n      // set animated color\n      if (this.startColor && this.age >= this.startColorChangeAt) {\n        this.system.setColor(index, Utils.lerpColors(this.startColor, this.endColor,\n          this.startColorChangeAt ? ((this.age - this.startColorChangeAt) / (1 - this.startColorChangeAt)) : this.age))\n      }\n\n      // set animated alpha\n      if (this.startAlpha != null && this.age >= this.startAlphaChangeAt) {\n        this.system.setAlpha(index, Utils.lerp(this.startAlpha, this.endAlpha,\n          this.startAlphaChangeAt ? ((this.age - this.startAlphaChangeAt) / (1 - this.startAlphaChangeAt)) : this.age))\n      }\n\n      // set animated size\n      if (this.startSize != null && this.age >= this.startSizeChangeAt) {\n        this.system.setSize(index, Utils.lerp(this.startSize, this.endSize,\n          this.startSizeChangeAt ? ((this.age - this.startSizeChangeAt) / (1 - this.startSizeChangeAt)) : this.age))\n      }\n    }\n\n    // add gravity force\n    if (this.gravity && this.velocity) {\n      this.velocity.y += this.gravity * deltaTime\n    }\n\n    // set animated rotation\n    if (this.rotationSpeed) {\n      this.rotation += this.rotationSpeed * deltaTime\n      this.system.setRotation(index, this.rotation)\n    }\n\n    // update position\n    if (this.velocity) {\n      this.position.x += this.velocity.x * deltaTime\n      this.position.y += this.velocity.y * deltaTime\n      this.position.z += this.velocity.z * deltaTime\n    }\n    var positionToSet = this.position\n\n    // to maintain world position\n    if (this.startWorldPosition) {\n      var systemPos = this.system.getWorldPosition()\n      systemPos.sub(this.startWorldPosition)\n      positionToSet = positionToSet.clone().sub(systemPos)\n    }\n\n    // set position in system\n    this.system.setPosition(index, positionToSet)\n\n    // update velocity\n    if (this.acceleration && this.velocity) {\n      this.velocity.x += this.acceleration.x * deltaTime\n      this.velocity.y += this.acceleration.y * deltaTime\n      this.velocity.z += this.acceleration.z * deltaTime\n    }\n\n    // update age. note: use ttl as factor, so that age is always between 0 and 1\n    this.age += deltaTime / this.ttl\n\n    // call custom methods\n    if (this.onUpdate) {\n      this.onUpdate(this)\n    }\n\n    // is done? set as finished and continue to set final state\n    if (this.age > 1) {\n      this.age = 1\n      this.finished = true\n    }\n  }\n\n  /**\n     * Get particle's world position.\n     */\n  get worldPosition () {\n    return this.system.getWorldPosition().add(this.position)\n  }\n}\n\n/**\n * Return either the value of a randomizer, a const value, or a default empty or null.\n */\nfunction getConstOrRandomVector (constValOrRandomizer, returnNullIfUndefined) {\n  if (!constValOrRandomizer) return (returnNullIfUndefined) ? null : new THREE.Vector3()\n  if (constValOrRandomizer.generate) return constValOrRandomizer.generate()\n  return constValOrRandomizer.clone()\n}\n\n/**\n * Return either the value of a randomizer, a const value, or a default empty or null.\n */\nfunction getConstOrRandomColor (constValOrRandomizer, returnNullIfUndefined) {\n  if (!constValOrRandomizer) return (returnNullIfUndefined) ? null : new THREE.Color(1, 1, 1)\n  if (constValOrRandomizer.generate) return constValOrRandomizer.generate()\n  return constValOrRandomizer.clone()\n}\n\nexport { Particle }\n","/**\n * Implement vertex shader for our particles.\n * Author: Ronen Ness.\n * Since: 2019.\n */\nconst VertexShaderCode = `\n// attributes we get from geometry\nattribute float alpha;\n\n// per-particle size\n#ifdef CONST_SIZE\n    uniform float constSize;\n#else\n    attribute float size;\n#endif\n\n// per-particle rotation\n#ifdef ROTATION\n    attribute float rotation;\n#endif\n\n// system scale when using perspective mode\n#ifdef PERSPECTIVE\n    uniform float rendererScale;\n#endif\n\n// output params for fragment shader\nvarying float vAlpha;\n\n// set per-particle color\n#ifdef COLORING\n    varying vec3 vColor;\n#endif\n\n// get per-particle rotation\n#ifdef ROTATION\n    varying float vRotation;\n#endif\n\n// vertex shader main\nvoid main() \n{\n    // alpha and color\n    vAlpha = alpha;\n\n    // set color\n    #ifdef COLORING\n        vColor = color;\n    #endif\n\n    // set const size\n    #ifdef CONST_SIZE\n        float size = constSize;\n    #endif\n\n    // set position\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    gl_Position = projectionMatrix * mvPosition;\n\n    // apply rotation\n    #ifdef ROTATION\n        vRotation = rotation;\n    #endif\n    \n    // set size - either perspective or constant\n    #ifdef PERSPECTIVE\n        gl_PointSize = size * (rendererScale / length(mvPosition.xyz));\n    #else\n        gl_PointSize = size;\n    #endif\n}\n`\nexport { VertexShaderCode }\n","/**\n * Create the shader material.\n * Author: Ronen Ness.\n * Since: 2019.\n */\nimport * as THREE from 'three'\nimport { VertexShaderCode } from './shaders/vertex'\nimport { FragmentShaderCode } from './shaders/fragment'\n\n/**\n * Material for particles.\n */\nclass ParticlesMaterial {\n  /**\n     * Create the particles material.\n     * @param {*} options Material options.\n     * @param {Number} options.color Material general color.\n     * @param {Boolean} options.transparent Should we support transparency?\n     * @param {THREE.Blending} options.blending Blending mode.\n     * @param {THREE.Texture} options.map Texture to use.\n     * @param {Boolean} options.perspective If true, will scale particles based on distance from camera.\n     * @param {Boolean} options.perParticleColor If true, will allow per-particle colors.\n     * @param {Boolean} options.perParticleRotation If true, will allow per-particle rotation.\n     * @param {Number} options.constSize If exist, will set const size to all particles.\n     * @param {Boolean} options.alphaTest If true, will perform alpha test and discard transparent pixels.\n     * @param {Boolean} options.depthWrite If true, will perform depth write.\n     * @param {Boolean} options.depthTest If true, will perform depth test.\n     */\n  constructor (options) {\n    // store options\n    this.options = options\n\n    // uniforms\n    var uniforms = {\n      globalColor: { value: new THREE.Color(options.color || 0xffffff) },\n      rendererScale: { value: 1 }\n    }\n\n    // set flags to change shaders behavior\n    var flags = ''\n    if (options.perspective) {\n      flags += '#define PERSPECTIVE\\n'\n    }\n    if (options.map) {\n      flags += '#define TEXTURE\\n'\n      uniforms.texture = { value: options.map }\n    }\n    if (options.perParticleColor) {\n      flags += '#define COLORING\\n'\n    }\n    if (options.perParticleRotation) {\n      flags += '#define ROTATION\\n'\n    }\n    if (options.constSize) {\n      flags += '#define CONST_SIZE\\n'\n      uniforms.constSize = { value: options.constSize }\n    }\n    if (options.alphaTest) {\n      flags += '#define ALPHA_TEST\\n'\n    }\n    flags += '\\n'\n\n    // create the internal material\n    var shaderMaterial = new THREE.ShaderMaterial({\n      uniforms: uniforms,\n      vertexShader: flags + VertexShaderCode,\n      fragmentShader: flags + FragmentShaderCode,\n      transparent: Boolean(options.transparent),\n      blending: options.blending,\n      vertexColors: THREE.VertexColors,\n      depthWrite: Boolean(options.depthWrite),\n      depthTest: Boolean(options.depthTest)\n    })\n    this.material = shaderMaterial\n  }\n\n  /**\n     * Dispose the material.\n     */\n  dispose () {\n    this.material.dispose()\n  }\n\n  /**\n     * Set unified scale for all particles.\n     */\n  setBaseScale (val) {\n    if (this.options.perspective) {\n      this.material.uniforms.rendererScale.value = val\n    }\n  }\n}\n\nexport { ParticlesMaterial }\n","/**\n * Implement fragment shader for our particles.\n * Author: Ronen Ness.\n * Since: 2019.\n */\n\nconst FragmentShaderCode = `\n// material uniforms\nuniform vec3 globalColor;\n\n// params we get from vertex shader\nvarying float vAlpha;\n\n// per-particle color from vertex shader\n#ifdef COLORING\n    varying vec3 vColor;\n#endif\n\n// per-particle rotation from vertex shader\n#ifdef ROTATION\n    varying float vRotation;\n#endif\n\n// diffuse texture\n#ifdef TEXTURE\n    uniform sampler2D texture;\n#endif\n\n// fragment shader main\nvoid main() \n{\n    // set default color if don't have per-particle colors\n    #ifndef COLORING\n        vec3 vColor = vec3(1,1,1);\n    #endif\n\n    // texture\n    #ifdef TEXTURE\n\n        // use rotation (rotate texture)\n        #ifdef ROTATION\n            float mid = 0.5;\n            vec2 rotated = vec2(cos(vRotation) * (gl_PointCoord.x - mid) + sin(vRotation) * (gl_PointCoord.y - mid) + mid,\n                          cos(vRotation) * (gl_PointCoord.y - mid) - sin(vRotation) * (gl_PointCoord.x - mid) + mid);\n            vec4 texture = texture2D(texture,  rotated);\n        // no rotation\n        #else\n            vec2 coords = vec2((gl_PointCoord.x - 0.5) + 0.5, (gl_PointCoord.y - 0.5) + 0.5);\n            vec4 texture = texture2D(texture, coords);\n        #endif\n\n        // get color with texture\n        gl_FragColor = vec4( globalColor * vColor, vAlpha ) * texture;\n        \n    // no texture (colors only)\n    #else\n        gl_FragColor = vec4( globalColor * vColor, vAlpha );\n    #endif\n\n    // check if need to discard pixel\n    #ifdef ALPHA_TEST\n        if (gl_FragColor.a < 0.00001) { discard; }\n    #endif\n}\n`\n\nexport { FragmentShaderCode }\n","/**\n * Implement basic particles system.\n * Author: Ronen Ness.\n * Since: 2019.\n*/\nimport * as THREE from 'three'\nimport { Particle } from './particle'\nimport { ParticlesMaterial } from './material/material'\n\n/**\n * Particles system.\n */\nclass ParticlesSystem {\n  /**\n     * Create particles system.\n     * @param {*} options Particles options.\n     * @param {THREE.Object3D} options.container Container to add particles system to.\n     *\n     * // PARTICLES OPTIONS\n     * ============================================================================\n     * @param {*} options.particles Particle-related options.\n     *\n     * // PARTICLES TTL\n     * @param {Number} options.particles.ttl How long, in seconds, every particle lives.\n     * @param {Number} options.particles.ttlExtra If provided, will add random numbers from 0 to ttlExtra to particle's ttl.\n     *\n     * // PARTICLES FADING / ALPHA\n     * @param {Boolean} options.particles.alpha Per-particle constant alpha; either a constant value (Number) or a Partykals.Randomizers.Randomizer instance to create random values.\n     * @param {Number} options.particles.startAlpha Particles starting opacity; either a constant value (Number) or a Partykals.Randomizers.Randomizer instance to create random values.\n     * @param {Number} options.particles.endAlpha Particles ending opacity; either a constant value (Number) or a Partykals.Randomizers.Randomizer instance to create random values.\n     * @param {Number} options.particles.startAlphaChangeAt Will only start shifting alpha when age is over this value; either a constant value (Number) or a Partykals.Randomizers.Randomizer instance to create random values.\n     *\n     * // PARTICLES GROWING / SIZE\n     * @param {Number} options.particles.size Per-particle constant size; either a constant value (Number) or a Partykals.Randomizers.Randomizer instance to create random values.\n     * @param {Number} options.particles.startSize Particles starting size; either a constant value (Number) or a Partykals.Randomizers.Randomizer instance to create random values.\n     * @param {Number} options.particles.endSize Particles ending size; either a constant value (Number) or a Partykals.Randomizers.Randomizer instance to create random values.\n     * @param {Number} options.particles.startSizeChangeAt Will only start shifting size when age is over this value; either a constant value (Number) or a Partykals.Randomizers.Randomizer instance to create random values.\n     *\n     * // PARTICLES COLORING\n     * @param {THREE.Color} options.particles.color Per-particle constant color; either a constant value (THREE.Color) or a Partykals.Randomizers.Randomizer instance to create random values.\n     * @param {THREE.Color} options.particles.startColor Starting color min value; either a constant value (THREE.Color) or a Partykals.Randomizers.Randomizer instance to create random values.\n     * @param {THREE.Color} options.particles.endColor Ending color min value; either a constant value (THREE.Color) or a Partykals.Randomizers.Randomizer instance to create random values.\n     * @param {Number} options.particles.startColorChangeAt Will only start shifting color when age is over this value; either a constant value (Number) or a Partykals.Randomizers.Randomizer instance to create random values.\n     *\n     * // PARTICLES ACCELERATION\n     * @param {THREE.Vector3} options.particles.acceleration Particles acceleration; either a constant value (THREE.Vector3) or a Partykals.Randomizers.Randomizer instance to create random values.\n     * @param {Number} options.particles.gravity Gravity force affecting the particles.\n     *\n     * // PARTICLES ROTATION\n     * @param {Number} options.particles.rotation Per-particle rotation (only works with texture); either a constant value (Number) or a Partykals.Randomizers.Randomizer instance to create random values.\n     * @param {Number} options.particles.rotationSpeed Particles rotation speed (only works with texture); either a constant value (Number) or a Partykals.Randomizers.Randomizer instance to create random values.\n     *\n     * // PARTICLES VELOCITY\n     * @param {*} options.particles.velocity Particles starting velocity; either a constant value (THREE.Vector3) or a Partykals.Randomizers.Randomizer instance to create random values.\n     * @param {THREE.Vector3} options.particles.velocityBonus Velocity value to add to all particles after randomizing velocity.\n     *\n     * // PARTICLES OFFSET\n     * @param {THREE.Vector3} options.particles.offset Particles offset from system's center; either a constant value (THREE.Vector3) or a Partykals.Randomizers.Randomizer instance to create random values.\n     *\n     * // PARTICLE GLOBALS\n     * @param {Boolean} options.particles.worldPosition If true, particles will maintain their world position after spawn even if the system moves.\n     * @param {Number} options.particles.globalSize Const size for all particles. Note: this is more efficient than setting per-particle size property.\n     * @param {Number} options.particles.globalColor Global color to affect all particles. Note: this is more efficient than setting per-particle color property.\n     * @param {String} options.particles.blending Particles blending mode (opaque / blend / additive).\n     * @param {THREE.Texture} options.particles.texture Particle's texture to use.\n     *\n     * // CUSTOM CALLBACKS\n     * @param {Function} options.particles.onUpdate Optional method to call per-particle every update frame.\n     * @param {Function} options.particles.onSpawn Optional method to call per-particle every time a particle spawns (after everything is set).\n     *\n     * // SYSTEM OPTIONS\n     * ============================================================================\n     * @param {*} options.system System-related options.\n     * @param {Number} options.system.particlesCount Particles count.\n     * @param {Number} options.system.ttl How long, in seconds, the particle system lives.\n     * @param {Number} options.system.speed Speed factor to affect all particles and emitting. Note: the only thing this don't affect is system's ttl.\n     * @param {Function} options.system.onUpdate Optional method to call every update frame.\n     * @param {Partykals.Emitter} options.system.emitters A single emitter or a list of emitters to attach to this system.\n     * @param {Boolean} options.system.perspective If true, will scale particles based on distance from camera.\n     * @param {Number} options.system.scale Overall system scale when in perspective mode (if perspective=false, will be ignored). A good value is between 400 and 600.\n     * @param {Boolean} options.system.depthWrite Should we perform depth write? (default to true).\n     * @param {Boolean} options.system.depthTest Should we perform depth test? (default to true).\n     */\n  constructor (options) {\n    // store options\n    options.particles = options.particles || { worldPosition: true }\n    options.system = options.system || {}\n    this.options = options\n\n    // to check if value is defined\n    var defined = (val) => { return (val !== undefined) && (val !== null) }\n\n    // get particle options\n    var poptions = options.particles\n\n    // do some internal cheating to replace const size with global size\n    if (typeof options.particles.size === 'number') {\n      console.warn(\"Note: replaced 'size' with 'globalSize' property since its more efficient and provided size value was constant anyway.\")\n      options.particles.globalSize = options.particles.size\n      delete options.particles.size\n    }\n\n    // do some internal cheating to replace const color with global color\n    if (options.particles.color instanceof THREE.Color) {\n      console.warn(\"Note: replaced 'color' with 'globalColor' property since its more efficient and you provided color value was constant anyway.\")\n      options.particles.globalColor = options.particles.color\n      delete options.particles.color\n    }\n\n    // set some internal flags\n    options.particles.fade = (defined(poptions.startAlpha) || defined(poptions.alpha))\n    options.particles.rotating = (defined(poptions.rotationSpeed) || defined(poptions.rotation))\n    options.particles.colorize = (defined(poptions.color) || defined(poptions.startColor))\n    options.particles.scaling = (defined(poptions.size) || defined(poptions.startSize))\n\n    // validate alpha params\n    if (defined(poptions.startAlpha) && !defined(poptions.endAlpha)) { throw new Error(\"When providing 'startAlpha' you must also provide 'endAlpha'!\") }\n    if (defined(poptions.startAlpha) && defined(poptions.alpha)) { throw new Error(\"When providing 'alpha' you can't also provide 'startAlpha'!\") }\n\n    // validate color params\n    if (defined(poptions.startColor) && !defined(poptions.endColor)) { throw new Error(\"When providing 'startColor' you must also provide 'endColor'!\") }\n    if (defined(poptions.startColor) && defined(poptions.color)) { throw new Error(\"When providing 'color' you can't also provide 'startColor'!\") }\n\n    // validate size params\n    if (defined(poptions.startSize) && !defined(poptions.endSize)) { throw new Error(\"When providing 'startSize' you must also provide 'endSize'!\") }\n    if (defined(poptions.startSize) && defined(poptions.size)) { throw new Error(\"When providing 'size' you can't also provide 'startSize'!\") }\n\n    // get particles count\n    var particleCount = options.system.particlesCount || 10\n\n    // get blending mode\n    var blending = options.particles.blending || 'opaque'\n\n    // get threejs blending mode\n    var threeBlend = {\n      opaque: THREE.NoBlending,\n      additive: THREE.AdditiveBlending,\n      multiply: THREE.MultiplyBlending,\n      blend: THREE.NormalBlending\n    }[blending]\n\n    // set emitters\n    this._emitters = []\n    if (options.system.emitters) {\n      if (options.system.emitters instanceof Array) {\n        for (var i = 0; i < options.system.emitters.length; ++i) {\n          this.addEmitter(options.system.emitters[i])\n        }\n      } else {\n        this.addEmitter(options.system.emitters)\n      }\n    }\n\n    // has transparency?\n    var isTransparent = (blending !== 'opaque')\n\n    // create the particle geometry\n    this.particlesGeometry = new THREE.BufferGeometry()\n\n    // set perspective mode\n    var perspective = options.system.perspective !== undefined ? Boolean(options.system.perspective) : true\n\n    // create particles material\n    var pMaterial = new ParticlesMaterial({\n      size: options.particles.size || 10,\n      color: options.particles.globalColor || 0xffffff,\n      blending: threeBlend,\n      perspective: perspective,\n      transparent: isTransparent,\n      map: options.particles.texture,\n      perParticleColor: Boolean(options.particles.colorize),\n      alphaTest: (blending === 'blend') && defined(options.particles.texture),\n      constSize: defined(options.particles.globalSize) ? options.particles.globalSize : null,\n      depthWrite: defined(options.system.depthWrite) ? options.system.depthWrite : true,\n      depthTest: defined(options.system.depthTest) ? options.system.depthTest : true,\n      perParticleRotation: options.particles.rotating\n    })\n\n    // store material for later usage\n    this.material = pMaterial\n\n    // store speed factor\n    this.speed = options.system.speed || 1\n\n    // set system starting ttl and other params\n    this.reset()\n\n    // dead particles and alive particles lists\n    this._aliveParticles = []\n    this._deadParticles = []\n\n    // create all particles + set geometry attributes\n    var vertices = new Float32Array(particleCount * 3)\n    var colors = options.particles.colorize ? new Float32Array(particleCount * 3) : null\n    var alphas = options.particles.fade ? new Float32Array(particleCount * 1) : null\n    var sizes = options.particles.scaling ? new Float32Array(particleCount * 1) : null\n    var rotations = options.particles.rotating ? new Float32Array(particleCount * 1) : null\n    for (var p = 0; p < particleCount; p++) {\n      var index = p * 3\n      vertices[index] = vertices[index + 1] = vertices[index + 2] = 0\n      if (colors) { colors[index] = colors[index + 1] = colors[index + 2] = 1 }\n      if (alphas) { alphas[p] = 1 }\n      if (sizes) { sizes[p] = 1 }\n      if (rotations) { rotations[p] = 0 }\n      this._deadParticles.push(new Particle(this))\n    }\n    this.particlesGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3))\n    if (alphas) { this.particlesGeometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1)) }\n    if (colors) { this.particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3)) }\n    if (sizes) { this.particlesGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1)) }\n    if (rotations) { this.particlesGeometry.setAttribute('rotation', new THREE.BufferAttribute(rotations, 1)) }\n    this.particlesGeometry.setDrawRange(0, 0)\n\n    // set scale\n    this.material.setBaseScale(options.system.scale || 400)\n\n    // create the particles system\n    var particleSystem = new THREE.Points(this.particlesGeometry, this.material.material)\n    particleSystem.sortParticles = isTransparent\n\n    // store particles system\n    this.particleSystem = particleSystem\n\n    // to make sure first update will update everything\n    this._positionDirty = true\n    this._colorsDirty = Boolean(colors)\n    this._alphaDirty = Boolean(alphas)\n    this._rotateDirty = Boolean(rotations)\n\n    // add it to the parent container\n    if (options.container) {\n      this.addTo(options.container)\n    }\n  }\n\n  /**\n     * Add emitter to this particles system.\n     */\n  addEmitter (emitter) {\n    this._emitters.push(emitter)\n  }\n\n  /**\n     * Dispose the entire system.\n     */\n  dispose () {\n    this.particlesGeometry.dispose()\n    this.material.dispose()\n  }\n\n  /**\n     * Return true when ttl is expired and there are no more alive particles in system.\n     */\n  get finished () {\n    return this.ttlExpired && (this.particlesCount === 0)\n  }\n\n  /**\n     * Get if this system's ttl is expired.\n     */\n  get ttlExpired () {\n    return (this.ttl !== undefined) && (this.ttl <= 0)\n  }\n\n  /**\n     * Reset particles system ttl.\n     */\n  reset () {\n    this.ttl = this.options.system.ttl\n    this.age = 0\n    this._timeToUpdateBS = 0\n  }\n\n  /**\n     * Get system's world position.\n     */\n  getWorldPosition () {\n    var ret = new THREE.Vector3()\n    this.particleSystem.getWorldPosition(ret)\n    return ret\n  }\n\n  /**\n     * Add the particles system to scene or container.\n     * @param {THREE.Object3D} container Container to add system to.\n     */\n  addTo (container) {\n    container.add(this.particleSystem)\n  }\n\n  /**\n     * Set a particle's color value.\n     */\n  setColor (index, color) {\n    index *= 3\n    var colors = this.particlesGeometry.attributes.color.array\n    colors[index] = color.r\n    colors[index + 1] = color.g\n    colors[index + 2] = color.b\n    this._colorsDirty = true\n  }\n\n  /**\n     * Set a particle's position.\n     */\n  setPosition (index, position) {\n    index *= 3\n    var vertices = this.particlesGeometry.attributes.position.array\n    vertices[index] = position.x\n    vertices[index + 1] = position.y\n    vertices[index + 2] = position.z\n    this._positionDirty = true\n  }\n\n  /**\n     * Set particle's alpha.\n     */\n  setAlpha (index, value) {\n    this.particlesGeometry.attributes.alpha.array[index] = value\n    this._alphaDirty = true\n  }\n\n  /**\n     * Set particle's rotation.\n     */\n  setRotation (index, value) {\n    this.particlesGeometry.attributes.rotation.array[index] = value\n    this._rotateDirty = true\n  }\n\n  /**\n     * Set particle's size.\n     */\n  setSize (index, value) {\n    this.particlesGeometry.attributes.size.array[index] = value\n    this._sizeDirty = true\n  }\n\n  /**\n     * Get how many particles this system currently shows.\n     */\n  get particlesCount () {\n    return this._aliveParticles.length\n  }\n\n  /**\n     * Get max particles count.\n     */\n  get maxParticlesCount () {\n    return this._aliveParticles.length + this._deadParticles.length\n  }\n\n  /**\n     * If ttl is expired and there are no more alive particles, remove system and dispose it.\n     * @returns True if removed & disposed, false if still alive.\n     */\n  removeAndDisposeIfFinished () {\n    if (this.finished) {\n      this.removeSelf()\n      this.dispose()\n      return true\n    }\n    return false\n  }\n\n  /**\n     * Update particles system.\n     */\n  update (deltaTime) {\n    // if deltaTime is undefined, set automatically\n    if (deltaTime === undefined) {\n      var timeNow = (new Date()).getTime() / 1000.0\n      deltaTime = (timeNow - this._lastTime) || 0\n      this._lastTime = timeNow\n    }\n\n    // delta time is 0? skip\n    if (deltaTime === 0) {\n      return\n    }\n\n    // update ttl\n    if (this.ttl !== undefined && this.ttl > 0) {\n      this.ttl -= deltaTime\n    }\n\n    // apply speed\n    deltaTime *= this.speed\n\n    // store last delta time\n    this.dt = deltaTime\n    this.age += deltaTime\n\n    // to check if number of particles changed\n    var prevParticlesCount = this._aliveParticles.length\n\n    // generate particles (unless ttl expired)\n    if (!this.ttlExpired) {\n      for (var i = 0; i < this._emitters.length; ++i) {\n        var toSpawn = this._emitters[i].update(deltaTime, this)\n        if (toSpawn) {\n          this.spawnParticles(toSpawn)\n        }\n      }\n    }\n\n    // update particles\n    for (var i = this._aliveParticles.length - 1; i >= 0; --i) {\n      // update particle\n      var particle = this._aliveParticles[i]\n      particle.update(i, deltaTime)\n\n      // finished? remove it\n      if (particle.finished) {\n        this._aliveParticles.splice(i, 1)\n        this._deadParticles.push(particle)\n      }\n    }\n\n    // hide invisible vertices\n    if (prevParticlesCount !== this._aliveParticles.length) {\n      this.particlesGeometry.setDrawRange(0, this._aliveParticles.length)\n    }\n\n    // set vertices dirty flag\n    this.particlesGeometry.attributes.position.needsUpdate = this._positionDirty\n    this._needBoundingSphereUpdate = this._needBoundingSphereUpdate || this._positionDirty\n    this._positionDirty = false\n\n    // set colors dirty flag\n    if (this._colorsDirty) {\n      this.particlesGeometry.attributes.color.needsUpdate = true\n      this._colorsDirty = false\n    }\n\n    // set alphas dirty flag\n    if (this._alphaDirty) {\n      this.particlesGeometry.attributes.alpha.needsUpdate = true\n      this._alphaDirty = false\n    }\n\n    // set size dirty flag\n    if (this._sizeDirty) {\n      this.particlesGeometry.attributes.size.needsUpdate = true\n      this._sizeDirty = false\n    }\n\n    // set rotation dirty flag\n    if (this._rotateDirty) {\n      this.particlesGeometry.attributes.rotation.needsUpdate = true\n      this._rotateDirty = false\n    }\n\n    // update bounding sphere\n    if (this._needBoundingSphereUpdate) {\n      this._timeToUpdateBS -= deltaTime\n      if (this._timeToUpdateBS <= 0) {\n        this._timeToUpdateBS = 0.2\n        this.particlesGeometry.computeBoundingSphere()\n      }\n    }\n\n    // if finished, stop here\n    if (this.finished) {\n      return\n    }\n\n    // call optional update\n    if (this.options.system.onUpdate) {\n      this.options.system.onUpdate(this)\n    }\n  }\n\n  /**\n     * Spawn particles.\n     * @param {Number} quantity Number of particles to spawn. If exceed max available particles in system, skip.\n     */\n  spawnParticles (quantity) {\n    // spawn particles\n    for (var i = 0; i < quantity; ++i) {\n      // no available dead particles? skip\n      if (this._deadParticles.length === 0) {\n        return\n      }\n\n      // spawn particle\n      var particle = this._deadParticles.pop()\n      particle.reset()\n      this._aliveParticles.push(particle)\n    }\n  }\n\n  /**\n     * Remove particles system from its parent.\n     */\n  removeSelf () {\n    if (this.particleSystem.parent) {\n      this.particleSystem.parent.remove(this.particleSystem)\n    }\n  };\n}\n\n// export the particles system\nexport { ParticlesSystem }\n","/**\n * Implement an emitter class to generate particles.\n * Author: Ronen Ness.\n * Since: 2019.\n*/\nimport { Utils } from './utils'\n\nvar randomizerOrValue = Utils.randomizerOrValue\n\n/**\n * Emitter class to determine rate of particles generation.\n */\nclass Emitter {\n  /**\n     * Create the emitter class.\n     * @param {*} options Emitter options.\n     * @param {*} options.onSpawnBurst Burst of particles when particle system starts; either a constant value (Number) or a Partykals.Randomizers.Randomizer instance to create random numbers.\n     * @param {*} options.onInterval Burst of particles every interval; either a constant value (Number) or a Partykals.Randomizers.Randomizer instance to create random numbers.\n     * @param {Number} options.interval Spawn interval time, in seconds; either a constant value (Number) or a Partykals.Randomizers.Randomizer instance to create random numbers.\n     * @param {Number} options.detoretingMinTtl If provided and particle system's ttl is below this value, will start emitting less and less until stopping completely.\n     */\n  constructor (options) {\n    this.options = options\n    options.interval = options.interval || 1\n    this.age = 0\n    this.timeToSpawn = Math.random() * randomizerOrValue(options.interval)\n  }\n\n  /**\n     * Update emitter and return how many particles should be generated this frame.\n     */\n  update (deltaTime, system) {\n    // particles to generate\n    var ret = 0\n\n    // first update? do burst\n    if (this.age === 0 && this.options.onSpawnBurst) {\n      ret += randomizerOrValue(this.options.onSpawnBurst)\n    }\n\n    // update age\n    this.age += deltaTime\n\n    // no interval emitting? skip\n    if (!this.options.onInterval) {\n      return ret\n    }\n\n    // check if inverval expired\n    this.timeToSpawn -= deltaTime\n    if (this.timeToSpawn <= 0) {\n      this.timeToSpawn = randomizerOrValue(this.options.interval)\n      ret += randomizerOrValue(this.options.onInterval)\n    }\n\n    // do detoration\n    if (this.options.detoretingMinTtl && system.ttl < this.options.detoretingMinTtl) {\n      var detorateFactor = system.ttl / this.options.detoretingMinTtl\n      ret *= detorateFactor\n    }\n\n    // return number of particles to generate\n    return ret\n  }\n}\n\n// export the emitter class\nexport { Emitter }\n","/**\n * Define interface for a helper class to generate random vectors and colors.\n * Author: Ronen Ness.\n * Since: 2019.\n*/\n\n/**\n * Base class for all vector randomizers.\n */\nclass Randomizer {\n  /**\n     * Generate and return a random value.\n     * This is the main method to implement.\n     */\n  generate () {\n    throw new Error('Not implemented.')\n  }\n}\n\n// export the base class\nexport { Randomizer }\n","/**\n * Generate vectors within a 3d sphere.\n * Author: Ronen Ness.\n * Since: 2019.\n*/\nimport * as THREE from 'three'\nimport { Randomizer } from './randomizer'\nimport { Utils } from '../utils'\n\n// random between -1 and 1.\nfunction randMinusToOne () {\n  return Math.random() * 2 - 1\n}\n\n/**\n * Sphere vector randomizer.\n */\nclass SphereRandomizer extends Randomizer {\n  /**\n     * Create the sphere randomizer from radius and optional scaler.\n     */\n  constructor (maxRadius, minRadius, scaler, minVector, maxVector) {\n    super()\n    this.maxRadius = maxRadius || 1\n    this.minRadius = minRadius || 0\n    this.scaler = scaler\n    this.minVector = minVector\n    this.maxVector = maxVector\n  }\n\n  /**\n     * Generate a random vector.\n     */\n  generate () {\n    // create random vector\n    var ret = new THREE.Vector3(randMinusToOne(), randMinusToOne(), randMinusToOne())\n\n    // clamp values\n    if (this.minVector || this.maxVector) {\n      ret.clamp(this.minVector || new THREE.Vector3(-1, -1, -1), this.maxVector || new THREE.Vector3(1, 1, 1))\n    }\n\n    // normalize and multiply by radius\n    ret.normalize().multiplyScalar(Utils.getRandomBetween(this.minRadius, this.maxRadius))\n\n    // apply scaler\n    if (this.scaler) { ret.multiply(this.scaler) }\n    return ret\n  }\n}\n\n// export the randomizer class\nexport { SphereRandomizer }\n","/**\n * Generate vectors within a 3d box.\n * Author: Ronen Ness.\n * Since: 2019.\n*/\nimport * as THREE from 'three'\nimport { Randomizer } from './randomizer'\nimport { Utils } from '../utils'\n\n/**\n * Box vector randomizer.\n */\nclass BoxRandomizer extends Randomizer {\n  /**\n     * Create the box randomizer from min and max vectors to randomize between.\n     */\n  constructor (min, max) {\n    super()\n    this.min = min || new THREE.Vector3(-1, -1, -1)\n    this.max = max || new THREE.Vector3(1, 1, 1)\n  }\n\n  /**\n     * Generate a random vector.\n     */\n  generate () {\n    return Utils.getRandomVectorBetween(this.min, this.max)\n  }\n}\n\n// export the randomizer class\nexport { BoxRandomizer }\n","/**\n * Generate vectors within a 3d box.\n * Author: Ronen Ness.\n * Since: 2019.\n*/\nimport * as THREE from 'three'\nimport { Randomizer } from './randomizer'\nimport { Utils } from '../utils'\n\n/**\n * Box vector randomizer.\n */\nclass ColorsRandomizer extends Randomizer {\n  /**\n     * Create the box randomizer from min and max colors to randomize between.\n     */\n  constructor (min, max) {\n    super()\n    this.min = min || new THREE.Color(0, 0, 0)\n    this.max = max || new THREE.Color(1, 1, 1)\n  }\n\n  /**\n     * Generate a random color.\n     */\n  generate () {\n    return Utils.getRandomColorBetween(this.min, this.max)\n  }\n}\n\n// export the randomizer class\nexport { ColorsRandomizer }\n","/**\n * Generate numbers between min and max.\n * Author: Ronen Ness.\n * Since: 2019.\n*/\nimport { Randomizer } from './randomizer'\nimport { Utils } from '../utils'\n\n/**\n * Min-Max number randomizer.\n */\nclass MinMaxRandomizer extends Randomizer {\n  /**\n     * Create the min-max randomizer from min and max.\n     */\n  constructor (min, max) {\n    super()\n    this.min = min\n    this.max = max\n  }\n\n  /**\n     * Generate a random number.\n     */\n  generate () {\n    return Utils.getRandomBetween(this.min, this.max)\n  }\n}\n\n// export the randomizer class\nexport { MinMaxRandomizer }\n"],"names":["Utils","getRandomBetween","min","max","Math","random","getRandomWithSpread","baseVal","extraRandom","this","getRandomColorBetween","colMin","colMax","THREE","r","g","b","clone","getRandomVectorBetween","vecMin","vecMax","x","y","z","lerpColors","colA","colB","alpha","lerp","randomizerOrValue","val","generate","Particle","constructor","system","reset","getConstOrRandomVector","constValOrRandomizer","returnNullIfUndefined","getConstOrRandomColor","options","particles","age","finished","gravity","velocity","velocityBonus","add","acceleration","position","offset","ttl","ttlExtra","startAlpha","endAlpha","startAlphaChangeAt","fade","undefined","colorize","Boolean","color","startColor","endColor","startColorChangeAt","size","startSize","endSize","startSizeChangeAt","scaling","rotation","rotationSpeed","rotating","startWorldPosition","onUpdate","onSpawn","update","index","deltaTime","worldPosition","getWorldPosition","setAlpha","setColor","setSize","setRotation","positionToSet","systemPos","sub","setPosition","const","ParticlesMaterial","uniforms","globalColor","value","rendererScale","flags","perspective","map","texture","perParticleColor","perParticleRotation","constSize","alphaTest","shaderMaterial","vertexShader","fragmentShader","transparent","blending","vertexColors","depthWrite","depthTest","material","dispose","setBaseScale","ParticlesSystem","defined","poptions","console","warn","globalSize","Error","particleCount","particlesCount","threeBlend","opaque","additive","multiply","blend","_emitters","emitters","Array","i","length","addEmitter","isTransparent","particlesGeometry","pMaterial","speed","_aliveParticles","_deadParticles","vertices","Float32Array","colors","alphas","sizes","rotations","p","push","setAttribute","setDrawRange","scale","particleSystem","sortParticles","_positionDirty","_colorsDirty","_alphaDirty","_rotateDirty","container","addTo","emitter","ttlExpired","_timeToUpdateBS","ret","attributes","array","_sizeDirty","maxParticlesCount","removeAndDisposeIfFinished","removeSelf","timeNow","Date","getTime","_lastTime","dt","prevParticlesCount","toSpawn","spawnParticles","particle","splice","needsUpdate","_needBoundingSphereUpdate","computeBoundingSphere","quantity","pop","parent","remove","Emitter","interval","timeToSpawn","onSpawnBurst","onInterval","detoretingMinTtl","Randomizer","randMinusToOne","maxRadius","minRadius","scaler","minVector","maxVector","clamp","normalize","multiplyScalar"],"mappings":"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"}